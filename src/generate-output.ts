import * as fs from 'fs';
import * as path from 'path';
import * as process from 'process';
import * as ts from 'typescript';

import { hasNodeModifier } from './helpers/typescript';
import { packageVersion } from './helpers/package-version';
import { OutputOptions } from './bundle-generator';

export interface ModuleImportsSet {
	defaultImports: Set<string>;
	starImports: Set<string>;
	namedImports: Set<string>;
	requireImports: Set<string>;
}

export interface OutputParams extends OutputHelpers {
	typesReferences: Set<string>;
	imports: Map<string, ModuleImportsSet>;
	statements: readonly ts.Statement[];
	renamedExports: string[];
}

export interface OutputHelpers {
	shouldStatementHasExportKeyword(statement: ts.Statement): boolean;
	needStripDefaultKeywordForStatement(statement: ts.Statement): boolean;
	needStripConstFromConstEnum(constEnum: ts.EnumDeclaration): boolean;
	needStripImportFromImportTypeNode(importType: ts.ImportTypeNode): boolean;
}

export function generateOutput(params: OutputParams, options: OutputOptions): string {
	let resultOutput = '';

	if (!options.noBanner) {
		resultOutput += `// Generated by dts-bundle-generator v${packageVersion()}\n\n`;
	}

	if (params.typesReferences.size !== 0) {
		const header = generateReferenceTypesDirective(Array.from(params.typesReferences));
		resultOutput += `${header}\n\n`;
	}

	if (params.imports.size !== 0) {
		// we need to have sorted imports of libraries to have more "stable" output
		const sortedEntries = Array.from(params.imports.entries()).sort((firstEntry: [string, ModuleImportsSet], secondEntry: [string, ModuleImportsSet]) => {
			return firstEntry[0].localeCompare(secondEntry[0]);
		});

		const importsArray: string[] = [];
		for (const [libraryName, libraryImports] of sortedEntries) {
			importsArray.push(...generateImports(libraryName, libraryImports));
		}

		if (importsArray.length !== 0) {
			resultOutput += `${importsArray.join('\n')}\n\n`;
		}
	}

	const statements = params.statements
		.filter(statement => {
			if (!options.includePaths) {
				return true;
			}
			const relPath = path.relative(process.cwd(), statement.getSourceFile().fileName);
			for (const includePath of options.includePaths) {
				const stat = fs.statSync(includePath);
				if (stat.isDirectory() &&
					relPath.startsWith(path.normalize(includePath + path.sep))) {
					return true;
				}
				if (stat.isFile() && (
					relPath === includePath ||
					// If includePath is a TypeScript file then also look for a
					// type declaration file of the same name, since that's
					// probably what it has been included as.
					relPath === includePath.replace(/\.ts$/, '.d.ts'))) {
					return true;
				}
			}
			return false;
		})
		.map(statement => getStatementText(statement, params, options));

	if (options.sortNodes) {
		statements.sort(compareStatementText);
	}

	resultOutput += statementsTextToString(statements, params, options);

	if (params.renamedExports.length !== 0) {
		resultOutput += `\n\nexport {\n\t${params.renamedExports.sort().join(',\n\t')},\n};`;
	}

	if (options.umdModuleName !== undefined) {
		resultOutput += `\n\nexport as namespace ${options.umdModuleName};`;
	}

	if (!options.reExportAllDeclarations) {
		// this is used to prevent importing non-exported nodes
		// see https://stackoverflow.com/questions/52583603/intentional-that-export-shuts-off-automatic-export-of-all-symbols-from-a-ty
		// Behind `options.reExportAllDeclarations` check to reduce probable noise.
		resultOutput += `\n\nexport {};\n`;
	}

	return resultOutput;
}

interface StatementText {
	leadingComment?: string;
	text: string;
}

function statementTextToString(s: StatementText): string {
	if (s.leadingComment === undefined) {
		return s.text;
	}

	return `${s.leadingComment}\n${s.text}`;
}

function statementsTextToString(statements: StatementText[], helpers: OutputHelpers, options: OutputOptions): string {
	const statementsText = statements.map(statementTextToString).join('\n');
	return spacesToTabs(prettifyStatementsText(statementsText, helpers, options));
}

function prettifyStatementsText(statementsText: string, helpers: OutputHelpers, options: OutputOptions): string {
	let sourceFile = ts.createSourceFile('output.d.ts', statementsText, ts.ScriptTarget.Latest, true, ts.ScriptKind.TS);
	const printer = ts.createPrinter(
		{
			newLine: ts.NewLineKind.LineFeed,
			removeComments: false,
		},
		{
			// eslint-disable-next-line complexity
			substituteNode: (hint: ts.EmitHint, node: ts.Node) => {
				if (options.excludeJSDocTags?.length) {
					if (findJSDocTags(node, options.excludeJSDocTags)) {
						return ts.factory.createIdentifier('__DELETE_NODE__');
					}
				}

				if (options.includeJSDocTags?.length && !ts.isSourceFile(node)) {
					let include = false;
					for (let n: ts.Node = node; n; n = n.parent) {
						if (findJSDocTags(n, options.includeJSDocTags)) {
							include = true;
							break;
						}
					}
					if (!include) {
						return ts.factory.createIdentifier('__DELETE_NODE__');
					}
				}

				if (options.excludePrivate && ts.isClassDeclaration(node)) {
					const nonPrivateMembers = node.members.filter(member =>
						!member.modifiers?.find(mod => mod.kind === ts.SyntaxKind.PrivateKeyword));
					if (nonPrivateMembers.length !== node.members.length) {
						node = ts.factory.updateClassDeclaration(node,
							node.decorators, node.modifiers, node.name, node.typeParameters, node.heritageClauses, nonPrivateMembers);
					}
				}

				// `import('module').Qualifier` or `typeof import('module').Qualifier`
				if (ts.isImportTypeNode(node) && node.qualifier !== undefined && helpers.needStripImportFromImportTypeNode(node)) {
					if (node.isTypeOf) {
						// I personally don't like this solution because it spreads the logic of modifying nodes in the code
						// I'd prefer to have it somewhere near getStatementText or so
						// but at the moment it seems that it's the fastest and most easiest way to remove `import('./module').` form the code
						// if you read this and know how to make it better - feel free to share your ideas/PR with fixes
						// tslint:disable-next-line:deprecation
						return ts.createTypeQueryNode(node.qualifier);
					}

					return ts.createTypeReferenceNode(node.qualifier, node.typeArguments);
				}

				return node;
			},
		}
	);

	// (kalman) Insert blank lines between each top-level statement - interface,
	// class, etc. I don't know a better way to do this.
	const blankLineStatement = ts.factory.createExpressionStatement(ts.factory.createIdentifier('__BLANK_LINE__'));
	const statements = [...sourceFile.statements];
	for (let i = statements.length - 2; i >= 0; i--) {
		statements.splice(i + 1, 0, blankLineStatement);
	}

	sourceFile = ts.factory.updateSourceFile(sourceFile, statements, sourceFile.isDeclarationFile, sourceFile.referencedFiles, sourceFile.typeReferenceDirectives, sourceFile.hasNoDefaultLib, sourceFile.libReferenceDirectives);
	let sourceCode = printer.printFile(sourceFile)
		// (kalman) the DELETE_NODE regexp is more complicated than expected in order to preserve blank lines.
		.replace(/(\n[ \t]+)?__DELETE_NODE__/g, '')
		.replace(/__BLANK_LINE__;/g, '');

	if (options.includeJSDocTags?.length) {
		// (kalman) Remove any jsdoc comments that are only created from whitespace and include tags.
		const cleanStrings = [
			'\\s',
			...options.includeJSDocTags.map(tag => '@' + tag)];
		const cleanRegExp = new RegExp('/\\*\\*((' + cleanStrings.join(')|(') + '))+\\*/\\s?', 'g');
		sourceCode = sourceCode.replace(cleanRegExp, '');
	}

	return sourceCode;
}

function compareStatementText(a: StatementText, b: StatementText): number {
	if (a.text > b.text) {
		return 1;
	} else if (a.text < b.text) {
		return -1;
	}

	return 0;
}

function needAddDeclareKeyword(statement: ts.Statement, nodeText: string): boolean {
	// for some reason TypeScript allows to do not write `declare` keyword for ClassDeclaration, FunctionDeclaration and VariableDeclaration
	// if it already has `export` keyword - so we need to add it
	// to avoid TS1046: Top-level declarations in .d.ts files must start with either a 'declare' or 'export' modifier.
	if (ts.isClassDeclaration(statement) && /^class\b/.test(nodeText)) {
		return true;
	}

	if (ts.isFunctionDeclaration(statement) && /^function\b/.test(nodeText)) {
		return true;
	}

	if (ts.isVariableStatement(statement) && /^(const|let|var)\b/.test(nodeText)) {
		return true;
	}

	return false;
}

function needStripDeclareKeyword(statement: ts.Statement, options: OutputOptions): boolean {
	return Boolean(
		ts.isEnumDeclaration(statement) &&
		statement.modifiers?.find(mod => mod.kind === ts.SyntaxKind.ConstKeyword) &&
		options.reDefineConstEnum
	);
}

// eslint-disable-next-line complexity
function getStatementText(statement: ts.Statement, helpers: OutputHelpers, options: OutputOptions): StatementText {
	const shouldStatementHasExportKeyword = helpers.shouldStatementHasExportKeyword(statement);
	const needStripDefaultKeyword = helpers.needStripDefaultKeywordForStatement(statement);
	const hasStatementExportKeyword = ts.isExportAssignment(statement) || hasNodeModifier(statement, ts.SyntaxKind.ExportKeyword);

	let nodeText = getTextAccordingExport(statement.getText(), hasStatementExportKeyword, shouldStatementHasExportKeyword);

	if (
		ts.isEnumDeclaration(statement)
		&& hasNodeModifier(statement, ts.SyntaxKind.ConstKeyword)
		&& helpers.needStripConstFromConstEnum(statement)) {
		nodeText = nodeText.replace(/\bconst\s/, '');
	}

	// strip the `default` keyword from node
	if (hasNodeModifier(statement, ts.SyntaxKind.DefaultKeyword) && needStripDefaultKeyword) {
		// we need just to remove `default` from any node except class node
		// for classes we need to replace `default` with `declare` instead
		nodeText = nodeText.replace(/\bdefault\s/, ts.isClassDeclaration(statement) ? 'declare ' : '');
	}

	if (needAddDeclareKeyword(statement, nodeText)) {
		nodeText = `declare ${nodeText}`;
	}

	if (needStripDeclareKeyword(statement, options)) {
		if (nodeText.startsWith('declare ')) {
			nodeText = nodeText.slice('declare '.length);
		} else if (nodeText.startsWith('export declare ')) {
			nodeText = 'export ' + nodeText.slice('export declare '.length);
		}
	}

	const result: StatementText = {
		text: nodeText,
	};

	// add jsdoc for exported nodes only
	if (shouldStatementHasExportKeyword) {
		const start = statement.getStart();
		const jsDocStart = statement.getStart(undefined, true);
		const nodeJSDoc = statement.getSourceFile().getFullText().substring(jsDocStart, start).trim();
		if (nodeJSDoc.length !== 0) {
			result.leadingComment = nodeJSDoc;
		}
	}

	return result;
}

function generateImports(libraryName: string, imports: ModuleImportsSet): string[] {
	const fromEnding = `from '${libraryName}';`;

	const result: string[] = [];

	// sort to make output more "stable"
	Array.from(imports.starImports).sort().forEach((importName: string) => result.push(`import * as ${importName} ${fromEnding}`));
	Array.from(imports.requireImports).sort().forEach((importName: string) => result.push(`import ${importName} = require('${libraryName}');`));
	Array.from(imports.defaultImports).sort().forEach((importName: string) => result.push(`import ${importName} ${fromEnding}`));

	if (imports.namedImports.size !== 0) {
		result.push(`import { ${Array.from(imports.namedImports).sort().join(', ')} } ${fromEnding}`);
	}

	return result;
}

function generateReferenceTypesDirective(libraries: string[]): string {
	return libraries.sort().map((library: string) => {
		return `/// <reference types="${library}" />`;
	}).join('\n');
}

function getTextAccordingExport(nodeText: string, isNodeExported: boolean, shouldNodeBeExported: boolean): string {
	if (shouldNodeBeExported && !isNodeExported) {
		return 'export ' + nodeText;
	} else if (isNodeExported && !shouldNodeBeExported) {
		return nodeText.slice('export '.length);
	}

	return nodeText;
}

function spacesToTabs(text: string): string {
	// eslint-disable-next-line no-regex-spaces
	return text.replace(/^(    )+/gm, (substring: string) => {
		return '\t'.repeat(substring.length / 4);
	});
}

function findJSDocTags(node: ts.Node, tags: string[]): string | undefined {
	const tagNames = ts.getJSDocTags(node).map(tag => tag.tagName.text);
	return tags.find(tag => tagNames.includes(tag));
}
